/-
Copyright (c) 2023 María Inés de Frutos-Fernández, Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import discrete_valuation_ring.extensions
import number_theory.ramification_inertia
import ring_theory.dedekind_domain.integral_closure

open local_ring valuation ideal --local_ring
open_locale discrete_valuation classical


/-
TODO: make hv implicit?
MI: I have made it implicit now
-/
noncomputable theory

universes u w

namespace discrete_valuation

variables (K : Type u) [field K] [hv : valued K ℤₘ₀] (L : Type w) [field L] [algebra K L] 

local notation `K₀` := hv.v.valuation_subring

include hv

/- As an alternative, we could define it as the ideal generated by the coercion of
a generator of `local_ring.maximal_ideal K₀`. -/
-- noncomputable!
@[reducible]
def extended_max_ideal : ideal (integral_closure K₀ L) :=
(map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀))
/- span {algebra_map K₀ (integral_closure K₀ L)
  (submodule.is_principal.generator (local_ring.maximal_ideal K₀))} -/

-- elaboration of extended_max_ideal_not_is_unit took 1.37s
lemma extended_max_ideal_not_is_unit : ¬ is_unit (extended_max_ideal K L) :=
begin
  have h₁ : algebra.is_integral K₀ (integral_closure K₀ L) := 
    le_integral_closure_iff_is_integral.mp (le_refl _),
  have h₂ : ring_hom.ker (algebra_map K₀ (integral_closure K₀ L)) ≤
    local_ring.maximal_ideal K₀,
  { exact local_ring.le_maximal_ideal (ring_hom.ker_ne_top _), },
  obtain ⟨Q, hQ_max, hQ⟩ := exists_ideal_over_maximal_of_is_integral h₁
     (local_ring.maximal_ideal K₀) h₂,
  rw [extended_max_ideal, ← hQ, is_unit_iff],
  exact ne_top_of_le_ne_top hQ_max.ne_top map_comap_le,
end


variables [is_discrete hv.v]

-- elaboration of extended_max_ideal_ne_zero took 1.62s
-- elaboration of extended_max_ideal_ne_zero took 1.75s, without the local_ring instance
lemma extended_max_ideal_ne_zero : 
  extended_max_ideal K L ≠ 0 :=
begin
  obtain ⟨π, hπ⟩ := discrete_valuation.exists_uniformizer_of_discrete hv.v, 
  rw [extended_max_ideal, ideal.map, ne.def, zero_eq_bot, span_eq_bot],
  simp only [set.mem_image, set_like.mem_coe, mem_maximal_ideal, mem_nonunits_iff, 
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, not_forall, exists_prop],
  use [π, uniformizer_not_is_unit hv.v hπ],
  rw [map_eq_zero_iff _, ← subring.coe_eq_zero_iff],
  exact (uniformizer_ne_zero hv.v hπ),
  { exact no_zero_smul_divisors.algebra_map_injective _ _ }
end


variables [finite_dimensional K L]

-- elaboration of integral_closure.is_noetherian took 1.5s
instance [is_separable K L] : is_noetherian K₀ (integral_closure K₀ L) :=
is_integral_closure.is_noetherian K₀ K L (integral_closure K₀ L)

variables [complete_space K] 

-- instance : discrete_valuation_ring (integral_closure K₀ L) :=
-- begin
--   exact integral_closure.discrete_valuation_ring_of_finite_extension K L,
-- end

-- set_option profiler true

-- instance : is_principal_ideal_ring (integral_closure K₀ L) :=
-- begin
--   -- have d := integral_closure.discrete_valuation_ring_of_finite_extension K L,
--   have u := @discrete_valuation_ring.to_is_principal_ideal_ring _ _ _
--     (integral_closure.discrete_valuation_ring_of_finite_extension K L),
--   exact u,
-- end

-- #exit

@[priority 10000]
instance dd : is_dedekind_domain (integral_closure K₀ L) :=
-- begin exact
@is_principal_ideal_ring.is_dedekind_domain _ _ _
  (@discrete_valuation_ring.to_is_principal_ideal_ring _ _ _
  (integral_closure.discrete_valuation_ring_of_finite_extension K L))
-- end
-- (@discrete_valuation_ring.to_is_principal_ideal_ring _ _ _
--     (integral_closure.discrete_valuation_ring_of_finite_extension K L).is_dedekind_domain
--     (integral_closure (hv.v.valuation_subring) L)

/- @[priority 10000]
noncomputable! lemma ufd : unique_factorization_monoid (ideal(integral_closure K₀ L)) :=
@ideal.unique_factorization_monoid (integral_closure K₀ L) _ _ _ -/

/-
noncomputable! def ccm : cancel_comm_monoid_with_zero (ideal(integral_closure K₀ L)) :=
@ideal.cancel_comm_monoid_with_zero (integral_closure K₀ L) _ _ _ -/

/- instance : discrete_valuation_ring (integral_closure K₀ L) := infer_instance

instance : local_ring (integral_closure K₀ L) := infer_instance -/

-- elaboration of ramification_idx_maximal_ne_zero took 6.36s, vs
-- elaboration of ramification_idx_maximal_ne_zero took 3.87s (with explicit dd)
lemma ramification_idx_maximal_ne_zero : ne_zero (ramification_idx
  (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L))) :=
begin
  apply ne_zero.mk,
  apply is_dedekind_domain.ramification_idx_ne_zero (extended_max_ideal_ne_zero K L),
  { apply is_maximal.is_prime' },
  { apply local_ring.le_maximal_ideal,
    intro h,
    apply extended_max_ideal_not_is_unit K L (is_unit_iff.mpr h) },
end

-- elaboration of ramification_idx_extended_ne_zero took 12.8s vs
-- elaboration of ramification_idx_extended_ne_zero took 9.72s (with explicit dd)
-- elaboration of ramification_idx_extended_ne_zero took 6.63s (removing unused have)
-- elaboration of ramification_idx_extended_ne_zero took 5.71s (removinf simp onlys)
lemma ramification_idx_extended_ne_zero : 
  ne_zero (ramification_idx (algebra_map K₀ (integral_closure K₀ L))
    (local_ring.maximal_ideal K₀) (extended_max_ideal K L)) :=
begin
  apply ne_zero.mk,
  apply ramification_idx_ne_zero nat.one_ne_zero,
  { rw [pow_one, extended_max_ideal],
    exact le_refl _ },
  { rw [← extended_max_ideal, one_add_one_eq_two, not_le],
    apply pow_lt_self,
    apply extended_max_ideal_ne_zero,
    { intro h,
      rw ← is_unit_iff at h,
      exact extended_max_ideal_not_is_unit K L h },
    exact le_refl _ }
end


-- elaboration of algebra_residue_fields took 762ms
noncomputable!
definition algebra_residue_fields : algebra (residue_field K₀)
  (residue_field (integral_closure K₀ L)) := 
begin
  apply quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀) _,
  exact ramification_idx_maximal_ne_zero K L,
end

-- elaboration of extended_eq_pow_ramification_index took 10.3s
-- elaboration of extended_eq_pow_ramification_index took 4.1s
lemma extended_eq_pow_ramification_index : (extended_max_ideal K L) 
    = local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      ) :=
begin
  -- sorry
  have := (((discrete_valuation_ring.tfae (integral_closure K₀ L) _).out 0 6).mp _),
    -- (extended_max_ideal K hv L) (extended_max_ideal_ne_zero K hv L),
  obtain ⟨n, hn⟩ := this (extended_max_ideal K L) (extended_max_ideal_ne_zero K L),
  rw [hn],
  { apply congr_arg,
    rw ramification_idx_spec, -- (le_of_eq hn),
    { exact le_of_eq hn },
    { rw [not_le, ← extended_max_ideal, hn],
      apply pow_succ_lt_pow,
      exact discrete_valuation_ring.not_a_field _ }},
  { exact discrete_valuation_ring.not_is_field _ },
  { apply_instance },
end

-- elaboration of algebra_mod_power_e took 3.08s
-- elaboration of algebra_mod_power_e took 2.22s
@[reducible]
def algebra_mod_power_e : algebra (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
    ))) :=
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) _ _,
  -- have := ramification_idx_extended_ne_zero K hv L,
  rw ← extended_eq_pow_ramification_index,
  apply ramification_idx_extended_ne_zero,
  -- { rw pow_one,
  --   simp only [le_refl] },
  -- { rw [not_le, one_add_one_eq_two, ← extended_eq_pow_ramification_index],
  --   apply pow_lt_self,
  --   { apply extended_max_ideal_ne_zero },
  --   { rw [ne.def,← is_unit_iff],
  --     apply extended_max_ideal_not_is_unit, },
  --   { simp only [le_refl]}},
  -- { exact nat.one_ne_zero },
end

-- elaboration of algebra_mod_extended took 1.38s
-- elaboration of algebra_mod_extended took 1.25s
@[reducible]
def algebra_mod_extended : algebra (residue_field K₀)
  ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) :=
begin
  rw [extended_eq_pow_ramification_index],
  exact (algebra_mod_power_e K L),
end

--elaboration of algebra_map_comp_extended took 167ms
-- elaboration of algebra_map_comp_extended took 59.8ms (in term mode)
lemma algebra_map_comp_extended : (@algebra_map (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L)))))
  _ _ (algebra_mod_power_e K L)) ∘ (ideal.quotient.mk (local_ring.maximal_ideal K₀)) =
  ideal.quotient.mk ((local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L)))))
  ∘ (algebra_map K₀ (integral_closure K₀ L)) :=
-- lemma algebra_map_comp_extended : (algebra_map (residue_field K₀)
--     ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
--     (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
--                               (local_ring.maximal_ideal K₀) 
--                               (local_ring.maximal_ideal (integral_closure K₀ L)))))
--   ) ∘ (ideal.quotient.mk (local_ring.maximal_ideal K₀)) =
--   ideal.quotient.mk ((local_ring.maximal_ideal (integral_closure K₀ L) ^ 
--     (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
--                               (local_ring.maximal_ideal K₀) 
--                               (local_ring.maximal_ideal (integral_closure K₀ L)))))
--   ∘ (algebra_map K₀ (integral_closure K₀ L)) :=
rfl

-- elaboration of algebra_map_comp_power_e took 16.9s
-- elaboration of algebra_map_comp_power_e took 18.8s
-- elaboration of algebra_map_comp_power_e took 7.75s (with "using 4")
lemma algebra_map_comp_power_e : (@algebra_map (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K L))
      _ _ (algebra_mod_extended K L)) ∘ (ideal.quotient.mk (local_ring.maximal_ideal K₀)) =
  ideal.quotient.mk (extended_max_ideal K L) ∘ (algebra_map K₀ (integral_closure K₀ L)) :=
/- lemma algebra_map_comp_power_e : (algebra_map (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K L))) ∘ (ideal.quotient.mk (local_ring.maximal_ideal K₀)) =
   ideal.quotient.mk (extended_max_ideal K L) ∘ (algebra_map K₀ (integral_closure K₀ L)) := -/
begin
  convert (algebra_map_comp_extended K L) using 4, 
  -- MI: the "using 4" really helped! (17 goals instead of 31)
  any_goals {rw extended_eq_pow_ramification_index},
  { simp only [algebra_mod_extended],
    simp only [eq_mpr_eq_cast, ← cast_cast, cast_heq], }
end

local attribute [instance] algebra_mod_power_e algebra_mod_extended

-- elaboration of algebra_map_comp_power_e_apply took 1.05s
lemma algebra_map_comp_power_e_apply (a : K₀) : 
  (algebra_map (residue_field K₀) ((integral_closure K₀ L) ⧸ (extended_max_ideal K L))) 
    (ideal.quotient.mk (local_ring.maximal_ideal K₀) a) =
  ideal.quotient.mk (extended_max_ideal K L) (algebra_map K₀ (integral_closure K₀ L) a) :=
begin
  have : ((algebra_map (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K L))
      ) ∘ (ideal.quotient.mk (local_ring.maximal_ideal K₀))) a =
  (ideal.quotient.mk (extended_max_ideal K L) ∘ (algebra_map K₀ (integral_closure K₀ L))) a,
  rwa algebra_map_comp_power_e
end


-- elaboration of scalar_tower_extended took 2.72s
-- elaboration of scalar_tower_extended took 2.09s
lemma scalar_tower_extended : is_scalar_tower K₀ (residue_field K₀)
  ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) :=
begin
  refine is_scalar_tower.of_algebra_map_eq (λ a, _),
  have algebra_map_comp : algebra_map K₀ ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) a =
    (ideal.quotient.mk (extended_max_ideal K L) ∘ (algebra_map K₀ (integral_closure K₀ L))) a,
  { refl },
  have algebra_map_eq_quot_mk : algebra_map K₀ (residue_field K₀) a =
    (ideal.quotient.mk (local_ring.maximal_ideal K₀)) a,
  { refl },
  rw [algebra_map_comp, ← algebra_map_comp_power_e, algebra_map_eq_quot_mk],
end

-- elaboration of scalar_tower_power_e took 5.63s
-- elaboration of scalar_tower_power_e took 4.26s
lemma scalar_tower_power_e : is_scalar_tower K₀ (residue_field K₀)
  ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
      (local_ring.maximal_ideal K₀) 
      (local_ring.maximal_ideal (integral_closure K₀ L))))) :=
begin
  refine is_scalar_tower.of_algebra_map_eq (λ a, _),
  have algebra_map_comp : algebra_map K₀ ((integral_closure K₀ L) ⧸
    (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))))) a =
    (ideal.quotient.mk ((local_ring.maximal_ideal (integral_closure K₀ L) ^ 
        (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))))) ∘ 
      (algebra_map K₀ (integral_closure K₀ L))) a,
  { refl },
  have algebra_map_eq_quot_mk : algebra_map K₀ (residue_field K₀) a =
    (ideal.quotient.mk (local_ring.maximal_ideal K₀)) a,
  refl,
  rw [algebra_map_comp, ← algebra_map_comp_extended, algebra_map_eq_quot_mk],
end

/- MI: This was a failed attempt to speed up quotient_linear_iso, but for some reason it takes
even longer...-/

 -- elaboration of quotient_linear_iso_aux took 16s
/-noncomputable! def quotient_linear_iso_aux :
  ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) →ₗ[residue_field K₀]
  ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))))) :=
{ to_fun    := λ x, (submodule.quot_equiv_of_eq _ _
    (extended_eq_pow_ramification_index K L)).restrict_scalars K₀ x,
  map_add'  := λ x y, map_add _ _ _,
  map_smul' := begin
    let f := (submodule.quot_equiv_of_eq _ _
    (extended_eq_pow_ramification_index K L)).restrict_scalars K₀,
    rintros ⟨a⟩ v,
    simp only [submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, embedding_like.apply_eq_iff_eq],
    have algebra_map_eq_quot_mk : algebra_map K₀ (residue_field K₀) a = (ideal.quotient.mk
      (local_ring.maximal_ideal K₀)) a,
    { refl },
    let scalar_tower_v := (scalar_tower_extended K L).1 a 1 v,
    let scalar_tower_fv := (scalar_tower_power_e K L).1 a 1 (f v),
    rw [← algebra.algebra_map_eq_smul_one a, one_smul, algebra_map_eq_quot_mk] at 
      scalar_tower_v scalar_tower_fv,
    rw [scalar_tower_v, ring_hom.id_apply, scalar_tower_fv],
    apply f.map_smul
  end } -/

-- elaboration of quotient_linear_iso took 14.8s
-- elaboration of quotient_linear_iso took 15.6s
noncomputable!
def quotient_linear_iso : ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) ≃ₗ[residue_field K₀]
  ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))))) :=
/- { to_fun := λ x, (submodule.quot_equiv_of_eq _ _
    (extended_eq_pow_ramification_index K L)).restrict_scalars K₀ x ,
  map_add' := λ x y , map_add _ _ _,
  map_smul' := sorry,
  inv_fun := sorry,
  left_inv := sorry,
  right_inv := sorry } -/
begin
  -- letI st_ext := scalar_tower_extended K hv L,
  let f := (submodule.quot_equiv_of_eq _ _
    (extended_eq_pow_ramification_index K L)).restrict_scalars K₀,
  let g :
  ((integral_closure K₀ L) ⧸ (extended_max_ideal K L))
  →ₗ[residue_field K₀]
  ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))))),
  { use λ x, f x,
    { apply f.map_add },
    { rintros ⟨a⟩ v,
      simp only [submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, embedding_like.apply_eq_iff_eq],
      have algebra_map_eq_quot_mk : algebra_map K₀ (residue_field K₀) a = (ideal.quotient.mk
        (local_ring.maximal_ideal K₀)) a,
      { refl },
      let scalar_tower_v := (scalar_tower_extended K L).1 a 1 v,
      let scalar_tower_fv := (scalar_tower_power_e K L).1 a 1 (f v),
      rw [← algebra.algebra_map_eq_smul_one a, one_smul, algebra_map_eq_quot_mk] at 
        scalar_tower_v scalar_tower_fv,
      rw [scalar_tower_v, ring_hom.id_apply, scalar_tower_fv],
      apply f.map_smul  }},
  have h : function.bijective g,
  { apply f.bijective },
  use linear_equiv.of_bijective g f.bijective,
end


local attribute [instance] algebra_residue_fields


/- elaboration of THE STATEMENT is fast (19.1ms) -/
-- elaboration of finite_dimensional_pow took 23.5s
-- elaboration of finite_dimensional_pow took 19.2s (without the dsimp onlys)
-- elaboration of finite_dimensional_pow took 18.3s (ending with exact)
-- elaboration of finite_dimensional_pow took 17.7s (using congr')
lemma finite_dimensional_pow [is_separable K L] :  finite_dimensional (residue_field K₀)
    ((map
            (ideal.quotient.mk
               (local_ring.maximal_ideal (integral_closure K₀ L) ^
                  ramification_idx
                    (algebra_map K₀
                       (integral_closure K₀ L))
                    (local_ring.maximal_ideal K₀)
                    (local_ring.maximal_ideal (integral_closure K₀ L))))
            (local_ring.maximal_ideal (integral_closure K₀ L) ^ 0)) ⧸
       linear_map.range
         (pow_quot_succ_inclusion
            (algebra_map K₀ (integral_closure K₀ L))
            (local_ring.maximal_ideal K₀)
            (local_ring.maximal_ideal (integral_closure K₀ L))
            0)) :=
begin
  have aux : finite_dimensional.finrank (K₀ ⧸ local_ring.maximal_ideal K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)) = finite_dimensional.finrank K L,
  { apply @finrank_quotient_map K₀ _ (integral_closure K₀ L) _ (local_ring.maximal_ideal K₀)
    _ K _ _ _ L _ _ (integral_closure.is_fraction_ring_of_finite_extension K L)
    _ _ _ _ _ _ _ _ _ _ }, -- 2.8s up to here
  haveI : finite_dimensional (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K L)),
  { suffices : 0 < finite_dimensional.finrank K L,
    { apply finite_dimensional.finite_dimensional_of_finrank,
      convert this using 1,
      --convert aux using 3,
      rw ← aux,
      congr' 2,
      --dsimp only [extended_max_ideal],--needed?
      apply algebra.algebra_ext,
      rintro ⟨a⟩,
      simp only [submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk,
        algebra_map_comp_power_e_apply K L a, ← quotient.algebra_map_quotient_map_quotient],
      refl },
    { rw finite_dimensional.finrank_pos_iff_exists_ne_zero,
      use 1,
      apply one_ne_zero }}, -- 8.82s up to here (proven)
  replace aux : finite_dimensional (residue_field K₀)
              (map (ideal.quotient.mk
                      ((local_ring.maximal_ideal (integral_closure K₀ L)) ^
                      (ramification_idx
                      (algebra_map K₀ (integral_closure K₀ L))
                      (local_ring.maximal_ideal K₀)
                      (local_ring.maximal_ideal (integral_closure K₀ L))
                      ))
                    )
              ((local_ring.maximal_ideal (integral_closure K₀ L)) ^ 0)),
    { rw [pow_zero, one_eq_top, ideal.map_top],
      haveI := (quotient_linear_iso K L).finite_dimensional,
      apply (@submodule.top_equiv (residue_field K₀) 
        ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^ 
        (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
        ))) _ _ _).symm.finite_dimensional  }, -- 10.9s (sorried); 16.7s (proven)
    --dsimp only [residue_field],--needed?
    exact @finite_dimensional.finite_dimensional_quotient (residue_field K₀) _ _ _ _ aux _,
end

/-The lemma `finrank_quotient_map` has an implicit variable `S` that should probably be made
explicit
-/

-- elaboration of finite_dimensional_residue_field_of_integral_closure took 44.1s
-- elaboration of finite_dimensional_residue_field_of_integral_closure took 41.1s
noncomputable!
lemma finite_dimensional_residue_field_of_integral_closure [is_separable K L] : 
  finite_dimensional (residue_field K₀) (residue_field (integral_closure K₀ L)) :=
begin
  let alg := (algebra_residue_fields K L),
  dsimp only [residue_field] at alg,
  letI := alg,
  letI h0 := ramification_idx_maximal_ne_zero K L,
  have zero_lt : 0 < (ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))), 
  { apply nat.pos_of_ne_zero h0.1 },
  let surj := quotient_range_pow_quot_succ_inclusion_equiv (algebra_map K₀
    (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)
    (local_ring.maximal_ideal (integral_closure K₀ L)) (discrete_valuation_ring.not_a_field _)
      zero_lt,
  apply @linear_equiv.finite_dimensional (residue_field K₀) _ _ _ _
    (residue_field (integral_closure K₀ L)) _ _ surj (finite_dimensional_pow K L),
  -- sorry
end

-- elaboration of finite_residue_field_of_integral_closure took 587ms
def finite_residue_field_of_integral_closure [is_separable K L] 
  (hres : fintype (residue_field K₀)) :
  fintype (residue_field (integral_closure K₀ L)) :=
begin
  letI := finite_dimensional_residue_field_of_integral_closure K L,
  exact (module.fintype_of_fintype (finite_dimensional.fin_basis 
    (residue_field K₀) (residue_field (integral_closure K₀ L)))),
end

-- elaboration of finite_residue_field_of_unit_ball took 118ms
def finite_residue_field_of_unit_ball [is_separable K L] 
  (hres : fintype (local_ring.residue_field K₀)) :
 fintype (residue_field (extended_valuation K L).valuation_subring) :=
@fintype.of_equiv _ _ (finite_residue_field_of_integral_closure K L hres) 
  (local_ring.residue_field.map_equiv
  (ring_equiv.subring_congr 
  (discrete_valuation.extension.integral_closure_eq_integer K L))).to_equiv

end discrete_valuation

-- #lint
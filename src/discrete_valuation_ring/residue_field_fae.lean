/-
Copyright (c) 2023 María Inés de Frutos-Fernández, Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import discrete_valuation_ring.extensions
import number_theory.ramification_inertia
import ring_theory.dedekind_domain.integral_closure

--
--Use `module.fintype_of_fintype` and `ideal.factors.finite_dimensional_quotient `
--and also `local_ring.residue_field.map_equiv`
.

open local_ring valuation --discrete_valuation
open_locale discrete_valuation classical

noncomputable theory

universes u w

namespace discrete_valuation

variables (K : Type u) [field K] (hv : valued K ℤₘ₀) (L : Type w) [field L] [algebra K L] 

local notation `K₀` := hv.v.valuation_subring

include hv

/- As an alternative, we could define it as the ideal generated by the coercion of
a generator of `local_ring.maximal_ideal K₀`. -/
-- noncomputable!
@[reducible]
def extended_max_ideal : ideal (integral_closure K₀ L) :=
(ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀))
/- ideal.span {algebra_map K₀ (integral_closure K₀ L)
  (submodule.is_principal.generator (local_ring.maximal_ideal K₀))} -/

variables [is_discrete hv.v] [complete_space K] [finite_dimensional K L]

-- lemma extended_max_ideal_coe_eq_max_ideal : (extended_max_ideal K hv L) = local_ring.maximal_ideal
--   (integral_closure K₀ L) := sorry


lemma extended_max_ideal_ne_zero : 
  extended_max_ideal K hv L ≠ 0 :=
begin
  obtain ⟨π, hπ⟩:= discrete_valuation.exists_uniformizer hv.v, 
  rw [extended_max_ideal, ideal.map, ne.def, ideal.zero_eq_bot, ideal.span_eq_bot],
  simp only [set.mem_image, set_like.mem_coe, mem_maximal_ideal, mem_nonunits_iff, 
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, not_forall, exists_prop],
  use [π, uniformizer_not_is_unit hv.v hπ],
  rw [map_eq_zero_iff _, ← subring.coe_eq_zero_iff],
  exact (uniformizer_ne_zero hv.v hπ),
  { exact no_zero_smul_divisors.algebra_map_injective _ _,}
end


lemma extended_max_ideal_not_is_unit : ¬ is_unit (extended_max_ideal K hv L) :=
begin
  have h₁ : algebra.is_integral K₀ (integral_closure K₀ L) := 
    le_integral_closure_iff_is_integral.mp (le_refl _),
  have h₂ : ring_hom.ker (algebra_map K₀ (integral_closure K₀ L)) ≤
    local_ring.maximal_ideal K₀,
  { apply local_ring.le_maximal_ideal,
    apply ring_hom.ker_ne_top },
  obtain ⟨Q, hQ_max, hQ⟩ := ideal.exists_ideal_over_maximal_of_is_integral h₁
     (local_ring.maximal_ideal K₀) h₂,
  rw [extended_max_ideal, ← hQ, ideal.is_unit_iff],
  apply ne_top_of_le_ne_top hQ_max.ne_top,
  apply ideal.map_comap_le,
end

-- lemma foo : ne_zero
--   (ideal.ramification_idx
--      (algebra_map K₀ (integral_closure K₀ L))
--      (local_ring.maximal_ideal K₀) (extended_max_ideal K hv L)) :=
-- begin
--   apply ne_zero.mk,
--   have := (((discrete_valuation_ring.tfae (integral_closure K₀ L) _).out 0 6).mp _),
--   specialize this (extended_max_ideal K hv L) (extended_max_ideal_ne_zero K hv L),
--   apply ideal.ramification_idx_ne_zero nat.one_ne_zero,
--   { rw pow_one,
--     rw extended_max_ideal,
--     simp only [le_refl],},
--   { rw ← extended_max_ideal,
--     rw one_add_one_eq_two,
--     rw not_le,
--     apply ideal.pow_lt_self,
--     apply extended_max_ideal_ne_zero,
--     { intro h,
--       rw ← ideal.is_unit_iff at h,
--       exact extended_max_ideal_not_is_unit K hv L h },
--     simp only [le_refl] },
--   { apply discrete_valuation_ring.not_is_field },
--   apply_instance,
-- end

-- noncomputable!
-- definition factor_of_extended : ideal (integral_closure K₀ L) :=
-- include L


instance [is_separable K L] : 
  is_noetherian K₀ (integral_closure K₀ L) :=
by exact is_integral_closure.is_noetherian K₀ K L (integral_closure K₀ L)

lemma ramification_idx_ne_zero : ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)) ≠ 0 :=
begin
  apply ideal.is_dedekind_domain.ramification_idx_ne_zero (extended_max_ideal_ne_zero K hv L),
  { apply_instance },
  { apply local_ring.le_maximal_ideal,
    intro h,
    rw ← ideal.is_unit_iff at h,
    exact extended_max_ideal_not_is_unit K hv L h },
end

-- lemma ramification_idx_ne_zero' : ideal.ramification_idx
--   (algebra_map K₀ (integral_closure K₀ L))
--   (local_ring.maximal_ideal K₀)
--   (extended_max_ideal K hv L) ≠ 0 :=
-- begin
--   sorry,
--   -- apply ideal.is_dedekind_domain.ramification_idx_ne_zero (extended_max_ideal_ne_zero K hv L),
--   -- { apply_instance },
--   -- { apply local_ring.le_maximal_ideal,
--   --   intro h,
--   --   rw ← ideal.is_unit_iff at h,
--   --   exact extended_max_ideal_not_is_unit K hv L h },
-- end

noncomputable!
definition alg_fae : algebra (residue_field K₀) (residue_field (integral_closure K₀ L)) := 
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀) _,
  apply ne_zero.mk,
  apply ramification_idx_ne_zero,
end


-- local attribute [instance] alg_fae


-- @[simp]
-- lemma coe_pow : local_ring.maximal_ideal (integral_closure K₀ L) ^
--   (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)
--     (local_ring.maximal_ideal (integral_closure K₀ L))) = extended_max_ideal K hv L :=
-- begin
--   sorry,
-- end

-- noncomputable!
-- definition alg_fae' : algebra (residue_field K₀)
--   (integral_closure K₀ L ⧸ (extended_max_ideal K hv L)) :=
-- begin
--   apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
--   (algebra_map K₀ (integral_closure K₀ L))
--     (local_ring.maximal_ideal K₀) _,
--   apply ne_zero.mk,
--   have := ramification_idx_ne_zero K hv L,
-- end

-- set_option profiler true

lemma extended_eq_pow_ramification_index : ideal.map (algebra_map K₀ (integral_closure K₀ L))
      (local_ring.maximal_ideal K₀) = local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      ) :=
begin
  have := (((discrete_valuation_ring.tfae (integral_closure K₀ L) _).out 0 6).mp _),
  obtain ⟨n, hn⟩ := this (extended_max_ideal K hv L) (extended_max_ideal_ne_zero K hv L),
  rw [← extended_max_ideal, hn],
  { congr,
    rw ideal.ramification_idx_spec,
    { rw [← extended_max_ideal],
      apply le_of_eq hn },
    { rw [not_le, ← extended_max_ideal, hn],
      apply ideal.pow_succ_lt_pow,
      apply discrete_valuation_ring.not_a_field }},
  { apply discrete_valuation_ring.not_is_field },
  { apply_instance, },
end

lemma minchia : @submodule.quotient_rel (integral_closure K₀ L) (integral_closure K₀ L) _ _ _
  (extended_max_ideal K hv L) = @submodule.quotient_rel (integral_closure K₀ L)
  (integral_closure K₀ L) _ _ _
  (local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      )) :=
begin
  rw extended_max_ideal,
  rw extended_eq_pow_ramification_index,
end

noncomputable!
def mod : algebra (residue_field K₀)
    ((integral_closure K₀ L) ⧸ local_ring.maximal_ideal (integral_closure K₀ L) ^ 
    (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
    )) :=
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) _ _,
  apply ne_zero.mk,
  apply ideal.ramification_idx_ne_zero _,
  rw extended_eq_pow_ramification_index,
  { rw pow_one,
    simp only [le_refl] },
  { rw [not_le, one_add_one_eq_two, ← extended_eq_pow_ramification_index],
    apply ideal.pow_lt_self,
    { apply extended_max_ideal_ne_zero },
    { rw [ne.def,← ideal.is_unit_iff],
      apply extended_max_ideal_not_is_unit, },
    { simp only [le_refl]}},
  { exact nat.one_ne_zero },
end


-- noncomputable!
-- def mod'' : module (residue_field K₀)
--     (residue_field (integral_closure K₀ L)) := sorry


/-**IMPORTANT** The final equality that I am required to prove at the end of
`lemma finite_dimensional_residue_field_of_integral_closure` is
`ideal.quotient.algebra_quotient_map_quotient = mod' K hv L`
and this 
1) Tells me a lot about what `mod' ` should really be
2) What is really being used in the proof
3) Using `equiv_quotient` instead of `equiv_quotient'` I am required to prove
`ideal.quotient.algebra_quotient_map_quotient = mod' K hv L`
which is the very same thing.
-/


noncomputable!
def mod' : algebra (residue_field K₀)
  ((integral_closure K₀ L) ⧸ (extended_max_ideal K hv L)) :=
-- def mod' : algebra (residue_field K₀)
--   ((integral_closure K₀ L) ⧸ ideal.map (algebra_map K₀ (integral_closure K₀ L))
--     (local_ring.maximal_ideal K₀)) :=
begin
  rw extended_max_ideal,
  rw extended_eq_pow_ramification_index,
  exact (mod K hv L),
end

lemma eq : mod' K hv L = ideal.quotient.algebra_quotient_map_quotient :=
begin
  rw mod',
  rw mod,
  -- have := ideal.quotient.algebra_map_eq (extended_max_ideal K hv L),
  simp only [eq_mpr_eq_cast, cast_cast],
  -- rw ideal.quotient.algebra_map_quotient_map_quotient,
  rw ideal.quotient.algebra_quotient_map_quotient,
  rw ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero,
  sorry,
  -- refl,
  -- refl,
  -- simp only,
  -- refl,
  -- rw sorry,
end


-- #exit

-- noncomputable!
-- def alg' : algebra (residue_field K₀)
--       ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L))) :=
--         alg_fae K hv L

-- noncomputable!
-- def alg' : algebra (K₀ ⧸ local_ring.maximal_ideal K₀)
--       ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L))) := sorry

local attribute [instance] mod mod' --alg_fae --mod''

lemma h_intcl: is_fraction_ring (integral_closure K₀ L) L := sorry

lemma uno' [is_separable K L] : finite_dimensional.finrank (K₀ ⧸ local_ring.maximal_ideal K₀)
    ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      ))) = finite_dimensional.finrank K L :=
begin
    have := @ideal.finrank_quotient_map K₀ _ (integral_closure K₀ L) _ (local_ring.maximal_ideal K₀)
    _ K _ _ _ L _ _ (h_intcl K hv L) _ _ _ _ _ _ _ _ _ _,
    rw ← this,
    apply linear_equiv.finrank_eq,

    -- have h_eq := @submodule.quot_equiv_of_eq K₀ (integral_closure K₀ L) _ _ _
    -- (extended_max_ideal K hv L),

    --  (local_ring.maximal_ideal (integral_closure K₀ L) ^
    --   (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
    --                           (local_ring.maximal_ideal K₀) 
    --                           (local_ring.maximal_ideal (integral_closure K₀ L))
    --   )) (extended_eq_pow_ramification_index K hv L)
    
    let := linear_equiv.restrict_scalars,-- _ h_eq,
    sorry,
    -- have min := minchia K hv L,
    -- rw extended_max_ideal at min,
    -- convert this,
    -- rw min at this,
    -- rw extended_eq_pow_ramification_index at this,
end

-- #exit

-- noncomputable!
-- definition equiv_quotient : ((integral_closure K₀ L) ⧸
--   local_ring.maximal_ideal (integral_closure K₀ L) ^ (ideal.ramification_idx
--   (algebra_map K₀ (integral_closure K₀ L))
--   (local_ring.maximal_ideal K₀)
--   (local_ring.maximal_ideal (integral_closure K₀ L)))) ≃ₗ[residue_field K₀]
--    (integral_closure K₀ L) ⧸
--     ideal.map (algebra_map K₀ (integral_closure K₀ L))
--       (local_ring.maximal_ideal K₀) := sorry

-- noncomputable!
-- definition equiv_quotient' : ((integral_closure K₀ L) ⧸
--   (local_ring.maximal_ideal (integral_closure K₀ L) ^ (ideal.ramification_idx
--   (algebra_map K₀ (integral_closure K₀ L))
--   (local_ring.maximal_ideal K₀)
--   (local_ring.maximal_ideal (integral_closure K₀ L)))))
--    ≃ₗ[residue_field K₀] 
--    (integral_closure K₀ L) ⧸
--     (ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)) := sorry

local attribute [instance] alg_fae

lemma temp [is_separable K L] :  finite_dimensional (residue_field K₀)
    ((ideal.map
            (ideal.quotient.mk
               (local_ring.maximal_ideal (integral_closure K₀ L) ^
                  ideal.ramification_idx
                    (algebra_map K₀
                       (integral_closure K₀ L))
                    (local_ring.maximal_ideal K₀)
                    (local_ring.maximal_ideal (integral_closure K₀ L))))
            (local_ring.maximal_ideal (integral_closure K₀ L) ^ 0)) ⧸
       linear_map.range
         (ideal.pow_quot_succ_inclusion
            (algebra_map K₀ (integral_closure K₀ L))
            (local_ring.maximal_ideal K₀)
            (local_ring.maximal_ideal (integral_closure K₀ L))
            0)) :=
begin
  have uno : finite_dimensional.finrank (K₀ ⧸ local_ring.maximal_ideal K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K hv L)) = finite_dimensional.finrank K L,
  { apply @ideal.finrank_quotient_map K₀ _ (integral_closure K₀ L) _ (local_ring.maximal_ideal K₀)
    _ K _ _ _ L _ _ (h_intcl K hv L) _ _ _ _ _ _ _ _ _ _, },
  replace uno : finite_dimensional (residue_field K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K hv L)), sorry,
  have due : finite_dimensional (residue_field K₀)
              (ideal.map (ideal.quotient.mk
                      ((local_ring.maximal_ideal (integral_closure K₀ L)) ^
                      (ideal.ramification_idx
                      (algebra_map K₀ (integral_closure K₀ L))
                      (local_ring.maximal_ideal K₀)
                      (local_ring.maximal_ideal (integral_closure K₀ L))
                      ))
                    )
              ((local_ring.maximal_ideal (integral_closure K₀ L)) ^ 0)),
    { --dsimp only [residue_field],
      rw pow_zero,
      -- convert uno,
      -- simp,
      sorry,

    },
    dsimp only [residue_field],
    apply @finite_dimensional.finite_dimensional_quotient (residue_field K₀) _ _ _ _ due,
end

/-The lemma `ideal.finrank_quotient_map` has an implicit variable `S` that should probably be made
explicit
-/
noncomputable!
lemma finite_dimensional_residue_field_of_integral_closure [is_separable K L] : 
  finite_dimensional (residue_field K₀) (residue_field (integral_closure K₀ L)) :=
begin
  let alg := (alg_fae K hv L),
  dsimp only [residue_field] at alg,
  letI := alg,
  haveI := ne_zero.mk (ramification_idx_ne_zero K hv L),
  have zero_lt : 0 < (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))), 
  sorry,
  have h_ne_zero : local_ring.maximal_ideal (integral_closure K₀ L) ≠ ⊥, sorry,
  let surj := ideal.quotient_range_pow_quot_succ_inclusion_equiv (algebra_map K₀
    (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)
    (local_ring.maximal_ideal (integral_closure K₀ L)) h_ne_zero zero_lt,
  -- rw ← residue_field at surj,
  -- have temp : finite_dimensional (residue_field K₀)
  --   ((ideal.map
  --           (ideal.quotient.mk
  --              (local_ring.maximal_ideal (integral_closure K₀ L) ^
  --                 ideal.ramification_idx
  --                   (algebra_map K₀
  --                      (integral_closure K₀ L))
  --                   (local_ring.maximal_ideal K₀)
  --                   (local_ring.maximal_ideal (integral_closure K₀ L))))
  --           (local_ring.maximal_ideal (integral_closure K₀ L) ^ 0)) ⧸
  --      linear_map.range
  --        (ideal.pow_quot_succ_inclusion
  --           (algebra_map K₀ (integral_closure K₀ L))
  --           (local_ring.maximal_ideal K₀)
  --           (local_ring.maximal_ideal (integral_closure K₀ L))
  --           0)), sorry,
  refine @linear_equiv.finite_dimensional (residue_field K₀) _ _ _ _
    (residue_field (integral_closure K₀ L)) _ _ surj (temp K hv L),
end

#exit



  have uno' : finite_dimensional.finrank (K₀ ⧸ local_ring.maximal_ideal K₀)
    ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      ))) = finite_dimensional.finrank K L := sorry,
  -- { sorry,
  --   --rw ← extended_eq_pow_ramification_index,
  --   -- apply @ideal.finrank_quotient_map K₀ _ (integral_closure K₀ L) _ (local_ring.maximal_ideal K₀)
  --   -- _ K _ _ _ L _ _ h_intcl _ _ _ _ _ _ _ _ _ _ 
  --   },
  -- have due := ideal.finrank_prime_pow_ramification_idx (algebra_map K₀ (integral_closure K₀ L))
  --   (local_ring.maximal_ideal K₀) (local_ring.maximal_ideal (integral_closure K₀ L))
  --   h_ne_zero (ramification_idx_ne_zero K hv L),
  have due' := ideal.rank_prime_pow_ramification_idx (algebra_map K₀ (integral_closure K₀ L))
    (local_ring.maximal_ideal K₀) (local_ring.maximal_ideal (integral_closure K₀ L))
    h_ne_zero (ramification_idx_ne_zero K hv L),
  -- have tre : local_ring.maximal_ideal (integral_closure K₀ L) ^
  -- ideal.ramification_idx
  --   (algebra_map K₀ (integral_closure K₀ L))
  --   (local_ring.maximal_ideal K₀)
  --   (local_ring.maximal_ideal (integral_closure K₀ L)) =
  --     extended_max_ideal K hv L, sorry,
  set e := ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)) with he,
  have he₀ : e ≠ 0 := ramification_idx_ne_zero K hv L,
  
  -- haveI inst_idx := ne_zero.mk (ramification_idx_ne_zero' K hv L),
  -- let cds := ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero
  --   (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀) 
  --   (extended_max_ideal K hv L),
  -- let quatrtr := @algebra.to_module _ _ _ _ cds,

    -- (ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero),

  -- have tre : finite_dimensional.finrank
  --   (K₀ ⧸ local_ring.maximal_ideal K₀)
  --   (  (integral_closure K₀ L) ⧸
  --      (local_ring.maximal_ideal (integral_closure K₀ L) ^
  --        (ideal.ramification_idx
  --          (algebra_map K₀ (integral_closure K₀ L))
  --          (local_ring.maximal_ideal K₀)
  --          (local_ring.maximal_ideal (integral_closure K₀ L))
  --         )
  --       )
  --   ) =
  -- (ideal.ramification_idx
  --     (algebra_map K₀ (integral_closure K₀ L))
  --     (local_ring.maximal_ideal K₀)
  --     (local_ring.maximal_ideal (integral_closure K₀ L))
  -- ) *

    -- have := @finite_dimensional.finrank
    --   (K₀ ⧸ local_ring.maximal_ideal K₀)
    --   ((integral_closure K₀ L) ⧸
    --   (extended_max_ideal K hv L)) _ _ quatrtr,
    -- have := finite_dimensional.finite_dimensional (K₀ ⧸ local_ring.maximal_ideal K₀)

    rw ← finite_dimensional.finite_dimensional_iff_of_rank_eq_nsmul he₀,
    swap,
    -- dsimp only [residue_field],
    exact due',
    apply finite_dimensional.finite_dimensional_of_finrank,
    -- have hope : M^e = extended_max_ideal K hv L, sorry,
    -- dsimp [extended_max_ideal] at uno,
    -- have hope : local_ring.maximal_ideal (integral_closure K₀ L) ^ e =
    --   ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀),sorry,
    have hop : 0 < finite_dimensional.finrank K L, sorry,
    convert hop using 1,
    -- rw ← uno',

  --   -- congr,
  --   -- rw extended_eq_pow_ramification_index,
  --   apply linear_equiv.finrank_eq,
  --   -- simp_rw he,
  --   convert equiv_quotient K hv L,
  --   -- convert uno,
  --   -- simp_rw [hM, eq_maximal_ideal],
  --   -- rw [hM, he],
  --   -- rw uno,
  -- -- congr,
  -- -- refl,/
  -- -- rw temp at due,
  -- -- simp at due,
  -- -- rw [coe_pow K hv L] at due,
  -- -- simp_rw coe_pow at due,
  -- -- have ff := finite_dimensional.finite_dimensional_of_finrank,
end

-- noncomputable! def alg' : 
--   algebra (residue_field K₀)
--     ((integral_closure K₀ L) ⧸ (prime_factor K L : ideal (integral_closure K₀ L))) := 
-- ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero (algebra_map _ _)
--     (local_ring.maximal_ideal K₀) (prime_factor K L)

end discrete_valuation
/-
Copyright (c) 2023 María Inés de Frutos-Fernández, Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import discrete_valuation_ring.extensions
import number_theory.ramification_inertia
import ring_theory.dedekind_domain.integral_closure

--
--Use `module.fintype_of_fintype` and `ideal.factors.finite_dimensional_quotient `
--and also `local_ring.residue_field.map_equiv`
.

open local_ring valuation --discrete_valuation
open_locale discrete_valuation classical

noncomputable theory

universes u w

namespace discrete_valuation

variables (K : Type u) [field K] (hv : valued K ℤₘ₀) (L : Type w) [field L] [algebra K L] 

local notation `K₀` := hv.v.valuation_subring

include hv

/- As an alternative, we could define it as the ideal generated by the coercion of
a generator of `local_ring.maximal_ideal K₀`. -/
-- noncomputable!
@[reducible]
def extended_max_ideal : ideal (integral_closure K₀ L) :=
(ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀))
/- ideal.span {algebra_map K₀ (integral_closure K₀ L)
  (submodule.is_principal.generator (local_ring.maximal_ideal K₀))} -/

variables [is_discrete hv.v] [complete_space K] [finite_dimensional K L]

-- lemma extended_max_ideal_coe_eq_max_ideal : (extended_max_ideal K hv L) = local_ring.maximal_ideal
--   (integral_closure K₀ L) := sorry


lemma extended_max_ideal_ne_zero : 
  extended_max_ideal K hv L ≠ 0 :=
begin
  obtain ⟨π, hπ⟩:= discrete_valuation.exists_uniformizer hv.v, 
  rw [extended_max_ideal, ideal.map, ne.def, ideal.zero_eq_bot, ideal.span_eq_bot],
  simp only [set.mem_image, set_like.mem_coe, mem_maximal_ideal, mem_nonunits_iff, 
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, not_forall, exists_prop],
  use [π, uniformizer_not_is_unit hv.v hπ],
  rw [map_eq_zero_iff _, ← subring.coe_eq_zero_iff],
  exact (uniformizer_ne_zero hv.v hπ),
  { exact no_zero_smul_divisors.algebra_map_injective _ _,}
end


lemma extended_max_ideal_not_is_unit : ¬ is_unit (extended_max_ideal K hv L) :=
begin
  have h₁ : algebra.is_integral K₀ (integral_closure K₀ L) := 
    le_integral_closure_iff_is_integral.mp (le_refl _),
  have h₂ : ring_hom.ker (algebra_map K₀ (integral_closure K₀ L)) ≤
    local_ring.maximal_ideal K₀,
  { apply local_ring.le_maximal_ideal,
    apply ring_hom.ker_ne_top },
  obtain ⟨Q, hQ_max, hQ⟩ := ideal.exists_ideal_over_maximal_of_is_integral h₁
     (local_ring.maximal_ideal K₀) h₂,
  rw [extended_max_ideal, ← hQ, ideal.is_unit_iff],
  apply ne_top_of_le_ne_top hQ_max.ne_top,
  apply ideal.map_comap_le,
end

-- lemma foo : ne_zero
--   (ideal.ramification_idx
--      (algebra_map K₀ (integral_closure K₀ L))
--      (local_ring.maximal_ideal K₀) (extended_max_ideal K hv L)) :=
-- begin
--   apply ne_zero.mk,
--   have := (((discrete_valuation_ring.tfae (integral_closure K₀ L) _).out 0 6).mp _),
--   specialize this (extended_max_ideal K hv L) (extended_max_ideal_ne_zero K hv L),
--   apply ideal.ramification_idx_ne_zero nat.one_ne_zero,
--   { rw pow_one,
--     rw extended_max_ideal,
--     simp only [le_refl],},
--   { rw ← extended_max_ideal,
--     rw one_add_one_eq_two,
--     rw not_le,
--     apply ideal.pow_lt_self,
--     apply extended_max_ideal_ne_zero,
--     { intro h,
--       rw ← ideal.is_unit_iff at h,
--       exact extended_max_ideal_not_is_unit K hv L h },
--     simp only [le_refl] },
--   { apply discrete_valuation_ring.not_is_field },
--   apply_instance,
-- end

-- noncomputable!
-- definition factor_of_extended : ideal (integral_closure K₀ L) :=
-- include L


instance [is_separable K L] : 
  is_noetherian K₀ (integral_closure K₀ L) :=
by exact is_integral_closure.is_noetherian K₀ K L (integral_closure K₀ L)

lemma ramification_idx_ne_zero : ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)) ≠ 0 :=
begin
  apply ideal.is_dedekind_domain.ramification_idx_ne_zero (extended_max_ideal_ne_zero K hv L),
  { apply_instance },
  { apply local_ring.le_maximal_ideal,
    intro h,
    rw ← ideal.is_unit_iff at h,
    exact extended_max_ideal_not_is_unit K hv L h },
end

lemma ramification_idx_ne_zero' : ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (extended_max_ideal K hv L) ≠ 0 :=
begin
  sorry,
  -- apply ideal.is_dedekind_domain.ramification_idx_ne_zero (extended_max_ideal_ne_zero K hv L),
  -- { apply_instance },
  -- { apply local_ring.le_maximal_ideal,
  --   intro h,
  --   rw ← ideal.is_unit_iff at h,
  --   exact extended_max_ideal_not_is_unit K hv L h },
end

noncomputable!
definition alg_fae : algebra (residue_field K₀) (residue_field (integral_closure K₀ L)) := 
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀) _,
  apply ne_zero.mk,
  apply ramification_idx_ne_zero,
end


-- local attribute [instance] alg_fae


-- @[simp]
-- lemma coe_pow : local_ring.maximal_ideal (integral_closure K₀ L) ^
--   (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)
--     (local_ring.maximal_ideal (integral_closure K₀ L))) = extended_max_ideal K hv L :=
-- begin
--   sorry,
-- end

-- noncomputable!
-- definition alg_fae' : algebra (residue_field K₀)
--   (integral_closure K₀ L ⧸ (extended_max_ideal K hv L)) :=
-- begin
--   apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
--   (algebra_map K₀ (integral_closure K₀ L))
--     (local_ring.maximal_ideal K₀) _,
--   apply ne_zero.mk,
--   have := ramification_idx_ne_zero K hv L,
-- end

noncomputable!
def mod (e : ℕ) : algebra (residue_field K₀)
    ((integral_closure K₀ L) ⧸ local_ring.maximal_ideal (integral_closure K₀ L) ^ e) :=
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
    (algebra_map K₀ (integral_closure K₀ L)) _ _,--(local_ring.maximal_ideal K₀) _,
  apply ne_zero.mk,
  have := ramification_idx_ne_zero K hv L,
  replace this : 0 < ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L))
    (local_ring.maximal_ideal K₀) (local_ring.maximal_ideal (integral_closure K₀ L)),
  { exact nat.pos_of_ne_zero this },
  sorry, 
end

-- noncomputable!
-- def mod'' : module (residue_field K₀)
--     (residue_field (integral_closure K₀ L)) := sorry


/-**IMPORTANT** The final equality that I am required to prove at the end of
`lemma finite_dimensional_residue_field_of_integral_closure` is
`ideal.quotient.algebra_quotient_map_quotient = mod' K hv L`
and this 
1) Tells me a lot about what `mod' ` should really be
2) What is really being used in the proof
3) Using `equiv_quotient` instead of `equiv_quotient'` I am required to prove
`ideal.quotient.algebra_quotient_map_quotient = mod' K hv L`
which is the very same thing.
-/


noncomputable!
def mod' : algebra (residue_field K₀)
  ((integral_closure K₀ L) ⧸
    ideal.map (algebra_map K₀ (integral_closure K₀ L))
      (local_ring.maximal_ideal K₀)) :=
begin
  have : ideal.map (algebra_map K₀ (integral_closure K₀ L))
      (local_ring.maximal_ideal K₀) = local_ring.maximal_ideal (integral_closure K₀ L) ^
      (ideal.ramification_idx (algebra_map K₀ (integral_closure K₀ L)) 
                              (local_ring.maximal_ideal K₀) 
                              (local_ring.maximal_ideal (integral_closure K₀ L))
      ), sorry,
  rw this,
  exact (mod K hv L _),
end

-- noncomputable!
-- def alg' : algebra (residue_field K₀)
--       ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L))) :=
--         alg_fae K hv L

-- noncomputable!
-- def alg' : algebra (K₀ ⧸ local_ring.maximal_ideal K₀)
--       ((integral_closure K₀ L) ⧸ (local_ring.maximal_ideal (integral_closure K₀ L))) := sorry

local attribute [instance] mod mod' alg_fae --mod''

noncomputable!
definition equiv_quotient : ((integral_closure K₀ L) ⧸
  local_ring.maximal_ideal (integral_closure K₀ L) ^ (ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)))) ≃ₗ[residue_field
    K₀] (integral_closure K₀ L) ⧸
    ideal.map (algebra_map K₀ (integral_closure K₀ L))
      (local_ring.maximal_ideal K₀) := sorry

noncomputable!
definition equiv_quotient' : ((integral_closure K₀ L) ⧸
  (local_ring.maximal_ideal (integral_closure K₀ L) ^ (ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)))))
   ≃ₗ[residue_field K₀] 
   (integral_closure K₀ L) ⧸
    (ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀)) := sorry

/-The lemma `ideal.finrank_quotient_map` has an implicit variable `S` that should probably be made
explicit
-/
noncomputable!
lemma finite_dimensional_residue_field_of_integral_closure [is_separable K L] : 
  finite_dimensional (residue_field K₀) (residue_field (integral_closure K₀ L)) :=
begin
  have h_intcl: is_fraction_ring ↥(integral_closure ↥(valued.v.valuation_subring) L) L, sorry,
  have h_ne_zero : local_ring.maximal_ideal (integral_closure K₀ L) ≠ ⊥, sorry,
  have uno : finite_dimensional.finrank (K₀ ⧸ local_ring.maximal_ideal K₀)
    ((integral_closure K₀ L) ⧸ (extended_max_ideal K hv L)) = finite_dimensional.finrank K L,
  { apply @ideal.finrank_quotient_map K₀ _ (integral_closure K₀ L) _ (local_ring.maximal_ideal K₀)
    _ K _ _ _ L _ _ h_intcl _ _ _ _ _ _ _ _ _ _ },
  -- have due := ideal.finrank_prime_pow_ramification_idx (algebra_map K₀ (integral_closure K₀ L))
  --   (local_ring.maximal_ideal K₀) (local_ring.maximal_ideal (integral_closure K₀ L))
  --   h_ne_zero (ramification_idx_ne_zero K hv L),
  have due' := ideal.rank_prime_pow_ramification_idx (algebra_map K₀ (integral_closure K₀ L))
    (local_ring.maximal_ideal K₀) (local_ring.maximal_ideal (integral_closure K₀ L))
    h_ne_zero (ramification_idx_ne_zero K hv L),
  -- have tre : local_ring.maximal_ideal (integral_closure K₀ L) ^
  -- ideal.ramification_idx
  --   (algebra_map K₀ (integral_closure K₀ L))
  --   (local_ring.maximal_ideal K₀)
  --   (local_ring.maximal_ideal (integral_closure K₀ L)) =
  --     extended_max_ideal K hv L, sorry,
  set e := ideal.ramification_idx
  (algebra_map K₀ (integral_closure K₀ L))
  (local_ring.maximal_ideal K₀)
  (local_ring.maximal_ideal (integral_closure K₀ L)) with he,
  have he₀ : e ≠ 0 := ramification_idx_ne_zero K hv L,
  
  -- haveI inst_idx := ne_zero.mk (ramification_idx_ne_zero' K hv L),
  -- let cds := ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero
  --   (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀) 
  --   (extended_max_ideal K hv L),
  -- let quatrtr := @algebra.to_module _ _ _ _ cds,

    -- (ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero),

  -- have tre : finite_dimensional.finrank
  --   (K₀ ⧸ local_ring.maximal_ideal K₀)
  --   (  (integral_closure K₀ L) ⧸
  --      (local_ring.maximal_ideal (integral_closure K₀ L) ^
  --        (ideal.ramification_idx
  --          (algebra_map K₀ (integral_closure K₀ L))
  --          (local_ring.maximal_ideal K₀)
  --          (local_ring.maximal_ideal (integral_closure K₀ L))
  --         )
  --       )
  --   ) =
  -- (ideal.ramification_idx
  --     (algebra_map K₀ (integral_closure K₀ L))
  --     (local_ring.maximal_ideal K₀)
  --     (local_ring.maximal_ideal (integral_closure K₀ L))
  -- ) *

    -- have := @finite_dimensional.finrank
    --   (K₀ ⧸ local_ring.maximal_ideal K₀)
    --   ((integral_closure K₀ L) ⧸
    --   (extended_max_ideal K hv L)) _ _ quatrtr,
    -- have := finite_dimensional.finite_dimensional (K₀ ⧸ local_ring.maximal_ideal K₀)

    rw ← finite_dimensional.finite_dimensional_iff_of_rank_eq_nsmul he₀,
    swap,
    -- dsimp only [residue_field],
    exact due',
    apply finite_dimensional.finite_dimensional_of_finrank,
    -- have hope : M^e = extended_max_ideal K hv L, sorry,
    dsimp [extended_max_ideal] at uno,
    -- have hope : local_ring.maximal_ideal (integral_closure K₀ L) ^ e =
    --   ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀),sorry,
    have hop : 0 < finite_dimensional.finrank K L, sorry,
    convert hop using 1,
    rw ← uno,
    apply linear_equiv.finrank_eq,
    -- simp_rw he,
    convert equiv_quotient K hv L,
    -- convert uno,
    -- simp_rw [hM, eq_maximal_ideal],
    -- rw [hM, he],
    -- rw uno,
  -- congr,
  -- refl,/
  -- rw temp at due,
  -- simp at due,
  -- rw [coe_pow K hv L] at due,
  -- simp_rw coe_pow at due,
  -- have ff := finite_dimensional.finite_dimensional_of_finrank,
end

-- noncomputable! def alg' : 
--   algebra (residue_field K₀)
--     ((integral_closure K₀ L) ⧸ (prime_factor K L : ideal (integral_closure K₀ L))) := 
-- ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero (algebra_map _ _)
--     (local_ring.maximal_ideal K₀) (prime_factor K L)

end discrete_valuation
/-
Copyright (c) 2023 María Inés de Frutos-Fernández, Filippo A. E. Nuccio. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández, Filippo A. E. Nuccio
-/

import discrete_valuation_ring.extensions
import number_theory.ramification_inertia
import ring_theory.dedekind_domain.integral_closure

--
--Use `module.fintype_of_fintype` and `ideal.factors.finite_dimensional_quotient `
--and also `local_ring.residue_field.map_equiv`
.

open local_ring valuation --discrete_valuation
open_locale discrete_valuation classical

noncomputable theory

universes u w

namespace discrete_valuation

variables (K : Type u) [field K] (hv : valued K ℤₘ₀) (L : Type w) [field L] [algebra K L] 

local notation `K₀` := hv.v.valuation_subring

include hv

/- As an alternative, we could define it as the ideal generated by the coercion of
a generator of `local_ring.maximal_ideal K₀`. -/
noncomputable!
def prime_factor' : ideal (integral_closure K₀ L) :=
(ideal.map (algebra_map K₀ (integral_closure K₀ L)) (local_ring.maximal_ideal K₀))
/- ideal.span {algebra_map K₀ (integral_closure K₀ L)
  (submodule.is_principal.generator (local_ring.maximal_ideal K₀))} -/

variables [is_discrete hv.v] [complete_space K] [finite_dimensional K L]

-- lemma prime_factor'_coe_eq_max_ideal : (prime_factor' K hv L) = local_ring.maximal_ideal
--   (integral_closure K₀ L) := sorry


lemma prime_factor'_ne_zero : 
  prime_factor' K hv L ≠ 0 :=
begin
  obtain ⟨π, hπ⟩:= discrete_valuation.exists_uniformizer hv.v, 
  rw [prime_factor', ideal.map, ne.def, ideal.zero_eq_bot, ideal.span_eq_bot],
  simp only [set.mem_image, set_like.mem_coe, mem_maximal_ideal, mem_nonunits_iff, 
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, not_forall, exists_prop],
  use [π, uniformizer_not_is_unit hv.v hπ],
  rw [map_eq_zero_iff _, ← subring.coe_eq_zero_iff],
  exact (uniformizer_ne_zero hv.v hπ),
  { exact no_zero_smul_divisors.algebra_map_injective _ _,}
end

example : algebra K₀ L := infer_instance
example : algebra.is_integral K₀ (integral_closure K₀ L) :=
begin
  apply le_integral_closure_iff_is_integral.mp,
  simp [le_refl],
end

lemma aux_inj : function.injective (algebra_map K₀ (integral_closure K₀ L)) :=
begin
   sorry,
end

lemma prime_factor'_not_is_unit : ¬ is_unit (prime_factor' K hv L) :=
begin
  have h₁ : algebra.is_integral K₀ (integral_closure K₀ L),
  { apply le_integral_closure_iff_is_integral.mp,
    simp [le_refl] },
  have h₂ : ring_hom.ker (algebra_map K₀ (integral_closure K₀ L)) = 0, sorry,
  replace h₂ : ring_hom.ker (algebra_map K₀ (integral_closure K₀ L)) ≤
    local_ring.maximal_ideal K₀, sorry,
  obtain ⟨Q, hQ_max, hQ_le⟩ := ideal.exists_ideal_over_maximal_of_is_integral h₁ (local_ring.maximal_ideal K₀)
    h₂,
  -- have h : ideal.span {submodule.is_principal.generator (local_ring.maximal_ideal K₀)} =
  --   local_ring.maximal_ideal K₀,
  -- { exact submodule.is_principal.span_singleton_generator _, },
  -- rw ideal.is_unit_iff,
  -- rw ideal.eq_top_iff_one,
  -- rw [prime_factor'],
  -- rw ← submodule.is_principal.span_singleton_generator (local_ring.maximal_ideal K₀),
  -- rw ideal.submodule_span_eq,
  -- rw ideal.map_span,
  -- sorry 
end

-- lemma foo : ne_zero
--   (ideal.ramification_idx
--      (algebra_map K₀ (integral_closure K₀ L))
--      (local_ring.maximal_ideal K₀) (prime_factor' K hv L)) :=
-- begin
--   apply ne_zero.mk,
--   have := (((discrete_valuation_ring.tfae (integral_closure K₀ L) _).out 0 6).mp _),
--   specialize this (prime_factor' K hv L) (prime_factor'_ne_zero K hv L),
--   apply ideal.ramification_idx_ne_zero nat.one_ne_zero,
--   { rw pow_one,
--     rw prime_factor',
--     simp only [le_refl],},
--   { rw ← prime_factor',
--     rw one_add_one_eq_two,
--     rw not_le,
--     apply ideal.pow_lt_self,
--     apply prime_factor'_ne_zero,
--     { intro h,
--       rw ← ideal.is_unit_iff at h,
--       exact prime_factor'_not_is_unit K hv L h },
--     simp only [le_refl] },
--   { apply discrete_valuation_ring.not_is_field },
--   apply_instance,
-- end

-- #exit

noncomputable!
def alg_fae : algebra (residue_field K₀) (residue_field (integral_closure K₀ L)) := 
begin
  apply ideal.quotient.algebra_quotient_of_ramification_idx_ne_zero 
  (algebra_map K₀ (integral_closure K₀ L))
    (local_ring.maximal_ideal K₀) _,
  apply ne_zero.mk,
  apply ideal.is_dedekind_domain.ramification_idx_ne_zero (prime_factor'_ne_zero K hv L),
  { apply_instance },
  { apply local_ring.le_maximal_ideal,
    intro h,
    rw ← ideal.is_unit_iff at h,
    exact prime_factor'_not_is_unit K hv L h },
end

end discrete_valuation